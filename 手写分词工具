# 涉及到的语料
import xlrd
from math import log

print("start...")
# 获取一个Book对象
workbook = xlrd.open_workbook("zhdic.xlsx")

dic_words = [] # 保存词典库中读取的单词(目前暂时用list)

# 获取一个sheet对象的列表
booksheet = workbook.sheet_by_index(0)

rows = booksheet.get_rows()
for row in rows:
    dic_words.append(row[0].value)

print("len:" + str(len(dic_words)))

print(dic_words)
# 以下是每一个单词出现的概率。为了问题的简化，我们只列出了一小部分单词的概率。 在这里没有出现的的单词但是出现在词典里的，统一把概率设置成为0.00001
# 比如 p("学院")=p("概率")=...0.00001

word_prob = {"北京":0.03,"的":0.08,"天":0.005,"气":0.005,"天气":0.06,"真":0.04,"好":0.05,"真好":0.04,"啊":0.01,"真好啊":0.02, 
             "今":0.01,"今天":0.07,"课程":0.06,"内容":0.06,"有":0.05,"很":0.03,"很有":0.04,"意思":0.06,"有意思":0.005,"课":0.01,
             "程":0.005,"经常":0.08,"意见":0.08,"意":0.01,"见":0.005,"有意见":0.02,"分歧":0.04,"分":0.02, "歧":0.005}

# 返回所有的分词结果
def word_break(s, wordDict):
    memo= {len(s): ['']}
    def sentences(i):
        if i not in memo:
            memo[i] = [s[i:j] + (tail and ',' + tail)
                       for j in range(i+1, len(s)+1)
                       if s[i:j] in wordDict
                       for tail in sentences(j)]
        return memo[i]
    list_res = sentences(0)
    list_new = []
    for line in list_res:
        line = line.split(",")
        list_new.append(line)
    return list_new

# 计算相识度返回最好的结果
def word_segment_naive(input_str):
    """
    1. 对于输入字符串做分词，并返回所有可行的分词之后的结果。
    2. 针对于每一个返回结果，计算句子的概率
    3. 返回概率最高的最作为最后结果
    
    input_str: 输入字符串   输入格式：“今天天气好”
    best_segment: 最好的分词结果  输出格式：["今天"，"天气"，"好"]
    """
    # TODO： 第一步： 计算所有可能的分词结果，要保证每个分完的词存在于词典里，这个结果有可能会非常多。 
# 存储所有分词的结果。如果次字符串不可能被完全切分，则返回空列表(list)
                 
    segments = word_break(input_str, dic_words)  # 存储所有分词的结果。如果次字符串不可能被完全切分，则返回空列表(list)
                   # 格式为：segments = [["今天"，“天气”，“好”],["今天"，“天“，”气”，“好”],["今“，”天"，“天气”，“好”],...]
#     print(segments)
    # TODO: 第二步：循环所有的分词结果，并计算出概率最高的分词结果，并返回
    best_segment = []
    best_score = 0.0
    for seg in segments:
        score_sum=0.0
        for word in seg:
            if word in word_prob:
                score_sum-=log(word_prob.get(word))
            else:
                score_sum-=log(0.00001)
        if best_score<score_sum:
            best_score=score_sum
            best_segment=seg
    
    return best_segment      
    
    
    
print(word_segment_naive("北京的天气真好啊"))



